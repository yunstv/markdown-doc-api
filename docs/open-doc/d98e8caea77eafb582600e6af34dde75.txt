{"__html":"<h2 id=\"dfed80594f05c5f7fb879481d5848b57\">网关签名验签</h2>\n<h3 id=\"7c6392d9070f2337cb136e75cab83c0c\">1. 接入网关签名</h3>\n<p> 对于接入开放平台网关，需要自行实现签名过程，以下为签名介绍。</p>\n<h4 id=\"72679a6a9370859bee7a2cf8db010e7d\">排序与拼接</h4>\n<p> 对请求参数<code>app_id</code>、<code>nonce</code>、<code>timestamp</code>、<code>api_code</code>、<code>request_content</code>按照第一个字符的键值 ASCII 码递增排序（字母升序排序），参数和参数值之间用<code>=</code>连接，参数之间用<code>&amp;</code>连接。 </p>\n<p> 用<code>私钥（ETC平台获取）</code>对UTF-8编码的签名字符串进行RSA签名,签名算法为<code>SHA1WithRSA</code>。</p>\n<h4 id=\"dfd535dee3ae105336ae3c5d5de2a3fe\">签名示例</h4>\n<p><strong>签名字符串示例</strong></p>\n<pre><code>api_code=test.add&amp;app_id=OIG0AF4DMOK2VC2N&amp;nonce=123AO9&amp;request_content={&quot;name&quot;:&quot;测试&quot;}&amp;timestamp=1604990109987</code></pre>\n<p><strong>java 签名示例</strong></p>\n<pre><code>    /**\n     * 用私钥对待签名字符串进行签名\n     * \n     * @param content \n     * @param privateKey\n     * @return\n     */\n    public static String rsaSign(String content, String privateKey) {\n        try {\n            PrivateKey priKey = getPrivateKeyFromPKCS8(&quot;RSA&quot;, new ByteArrayInputStream(privateKey.getBytes()));\n            Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;);\n            signature.initSign(priKey);\n            signature.update(content.getBytes(StandardCharsets.UTF_8));\n            byte[] signed = signature.sign();\n            return new String(Base64.encodeBase64(signed));\n        } catch (Exception var7) {\n            throw new BusinessException(&quot;401001&quot;, var7.getMessage());\n        }\n    }\n    public static PrivateKey getPrivateKeyFromPKCS8(String algorithm, InputStream ins) throws Exception {\n        if (ins != null &amp;&amp; !StringUtils.isBlank(algorithm)) {\n            KeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n            byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();\n            encodedKey = Base64.decodeBase64(encodedKey);\n            return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(encodedKey));\n        } else {\n            return null;\n        }\n    }</code></pre>\n<h3 id=\"f9ed2c6469865169a7816d170e4cb576\">2. 网关对内转发签名与验签</h3>\n<h4 id=\"0e5b59fbdf35e537a5d825a298b9b407\">2.1 网关签名</h4>\n<p> 对<code>requestHeaders</code>中的<code>app-id</code>、<code>biz-user-id</code>、<code>timestamp</code>、<code>request-id</code>按照第一个字符的键值 ASCII 码递增排序（字母升序排序），参数和参数值之间用<code>=</code>连接，参数之间用<code>&amp;</code>连接。</p>\n<p><strong>待签名字符串示例</strong></p>\n<pre><code>app-id=OIG0AF4DMOK2VC2N&amp;request-id=EHfbfL2UDYMM8VQpnQER&amp;timestamp=1604990109987&amp;biz-user-id=E0019182</code></pre>\n<h4 id=\"f9ff2f21680b87794993186b837af1db\">2.2 内部服务验签</h4>\n<p> 对<code>requestHeaders</code>中的<code>app-id</code>、<code>biz-user-id</code>、<code>timestamp</code>、<code>request-id</code>按照第一个字符的键值 ASCII 码递增排序（字母升序排序），参数和参数值之间用<code>=</code>连接，参数之间用<code>&amp;</code>连接。</p>\n<p> 内部服务接收到请求后，用相同的逻辑组装好签名字符串，然后用公钥和接收到的签名验签，UTF-8编码。</p>\n<p><strong>待验签名字符串示例</strong></p>\n<pre><code>app-id=OIG0AF4DMOK2VC2N&amp;request-id=EHfbfL2UDYMM8VQpnQER&amp;timestamp=1604990109987&amp;biz-user-id=E0019182</code></pre>\n<p><strong>java 验签示例</strong></p>\n<pre><code>    /**\n     * 用公钥和签名字符串对签名进行验证\n     * \n     * @param content \n     *@param sign\n     * @param publicKey\n     * @return\n     */\n    public static boolean rsaCheckContent(String content, String sign, String publicKey) {\n        try {\n            PublicKey pubKey = getPublicKeyFromX509(&quot;RSA&quot;, new ByteArrayInputStream(publicKey.getBytes()));\n            Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;);\n            signature.initVerify(pubKey);\n            signature.update(content.getBytes(StandardCharsets.UTF_8));\n            return signature.verify(Base64.decodeBase64(sign.getBytes()));\n        } catch (Exception var6) {\n            throw new BusinessException(&quot;401001&quot;, var6.getMessage());\n        }\n    }\n    public static PublicKey getPublicKeyFromX509(String algorithm, InputStream ins) throws Exception {\n        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n        byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();\n        encodedKey = Base64.decodeBase64(encodedKey);\n        return keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));\n    }</code></pre>\n<p><strong>java 签名验签工具类示例</strong></p>\n<pre><code>import org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.text.NumberFormat;\nimport java.util.*;\n\npublic class SignatureUtil {\n\n\n    public static String getSignContent(Map&lt;String, Object&gt; params) {\n        params.remove(&quot;sign&quot;);\n        StringJoiner stringJoiner = new StringJoiner(&quot;&amp;&quot;);\n        List&lt;String&gt; keys = new ArrayList(params.keySet());\n        Collections.sort(keys);\n        keys.stream().filter(StringUtils::notBlank).forEach(key -&gt; {\n            Object value = params.get(key);\n            stringJoiner.add(key + &quot;=&quot; + value.toString());\n        });\n\n        return stringJoiner.toString();\n    }\n\n\n    public static String rsaSign(Map&lt;String, Object&gt; params, String privateKey) throws Exception {\n        String signContent = getSignContent(params);\n        return rsaSign(signContent, privateKey);\n    }\n\n    /**\n     * 用私钥对待签名字符串进行签名\n     *\n     * @param content\n     * @param privateKey\n     * @return\n     */\n    public static String rsaSign(String content, String privateKey) throws Exception {\n        PrivateKey priKey = getPrivateKeyFromPKCS8(&quot;RSA&quot;, new ByteArrayInputStream(privateKey.getBytes()));\n        Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;);\n        signature.initSign(priKey);\n        signature.update(content.getBytes(StandardCharsets.UTF_8));\n\n        byte[] signed = signature.sign();\n        return new String(Base64.encodeBase64(signed));\n    }\n\n    public static PrivateKey getPrivateKeyFromPKCS8(String algorithm, InputStream ins) throws Exception {\n        if (ins != null &amp;&amp; !StringUtils.isBlank(algorithm)) {\n            KeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n            byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();\n            encodedKey = Base64.decodeBase64(encodedKey);\n            return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(encodedKey));\n        } else {\n            return null;\n        }\n    }\n\n\n    public static boolean rsaCheck(Map&lt;String, Object&gt; params, String publicKey) throws Exception {\n        String sign = (String) params.get(&quot;sign&quot;);\n        String content = getSignContent(params);\n        return rsaCheckContent(content, sign, publicKey);\n    }\n\n\n    /**\n     * 用公钥和签名字符串对签名进行验证\n     *\n     * @param content\n     * @param sign\n     * @param publicKey\n     * @return\n     */\n    public static boolean rsaCheckContent(String content, String sign, String publicKey) throws Exception {\n        PublicKey pubKey = getPublicKeyFromX509(&quot;RSA&quot;, new ByteArrayInputStream(publicKey.getBytes()));\n        Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;);\n        signature.initVerify(pubKey);\n        signature.update(content.getBytes(StandardCharsets.UTF_8));\n\n        return signature.verify(Base64.decodeBase64(sign.getBytes()));\n    }\n\n    public static PublicKey getPublicKeyFromX509(String algorithm, InputStream ins) throws Exception {\n        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n        byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();\n        encodedKey = Base64.decodeBase64(encodedKey);\n        return keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));\n    }\n\n}</code></pre>\n","key":"d98e8caea77eafb582600e6af34dde75","docType":"open-doc","fileName":"__open-docs_01-网关签名_03-网关签名验签.json","mtimeMs":1622776519000,"birthtimeMs":1622776519000}