{"__html":"<h2 id=\"8a0881c5fe83ec3bd307e8f26d7120eb\">网关签名验签</h2>\n<h3 id=\"ccddd3d9ab7a97d0b52b6e934a32a6b3\">签名字符串</h3>\n<p> 对参数appId、nonce、timestamp、apiCode、业务参数进行字典排序，参数和值之间用“=”连接，参数之间用“&amp;”连接。 <br/><code>注：业务参数为params对象里的所有非对象、数组、集合类型的参数</code></p>\n<p><strong>签名字符串示例</strong></p>\n<pre><code>apiCode=test.add&amp;appId=OIG0AF4DMOK2VC2N&amp;name=测试&amp;nonce=123AO9&amp;timestamp=1604990109987</code></pre>\n<h3 id=\"a7eebff66c00a0828f69b32a796ccd28\">加签</h3>\n<p>用<code>私钥（ETC平台获取）</code>对UTF-8编码的签名字符串进行RSA签名,签名算法为<code>SHA1WithRSA</code>。</p>\n<p><strong>java 签名示例</strong></p>\n<pre><code>    /**\n     * 用私钥对待签名字符串进行签名\n     * \n     * @param content \n     * @param privateKey\n     * @return\n     */\n    public static String rsaSign(String content, String privateKey) {\n        try {\n            PrivateKey priKey = getPrivateKeyFromPKCS8(&quot;RSA&quot;, new ByteArrayInputStream(privateKey.getBytes()));\n            Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;);\n            signature.initSign(priKey);\n            signature.update(content.getBytes(StandardCharsets.UTF_8));\n            byte[] signed = signature.sign();\n            return new String(Base64.encodeBase64(signed));\n        } catch (Exception var7) {\n            throw new BusinessException(&quot;401001&quot;, var7.getMessage());\n        }\n    }\n    public static PrivateKey getPrivateKeyFromPKCS8(String algorithm, InputStream ins) throws Exception {\n        if (ins != null &amp;&amp; !StringUtils.isBlank(algorithm)) {\n            KeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n            byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();\n            encodedKey = Base64.decodeBase64(encodedKey);\n            return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(encodedKey));\n        } else {\n            return null;\n        }\n    }</code></pre>\n<p><strong>签名私钥示例</strong></p>\n<pre><code>MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAJYmnqO24pylH6D4+JBszn52ZV+hssW+77CaoNsnrPCUtD8ZXBPQ6tiPMhkFyJNrSMRUsQthOKlSD3Q+rPpjsAGAa+4OhFUs8R2oK9vej3SF+7zZ04cKJG+fLjGxa4R2bmzVbubZL+BAk9Y2qa1IKV7NNS7jT38O6sEzFRBik1ybAgMBAAECgYB3PxSeUJCId1s3LIO7r64PIVhBKtof0hPp3eQCKPBf4LmFo05NLo5UjuTqmn1BFuMjiV9R+lRVpKZBW8Vk1ebhEnej7+SEAyrTU2jFE/7+V+JYChWJY3ipyvnWnLvGNIB9Er0wHGK8R9o7lDi0+592x1tuOrxud1nJ56ID4DgfAQJBAM/77Z0nkbvEgdJ0hgSXAvwZ1EjSGtkGFVELlsuYM6kt3xQ+FCk2fmuiE7t8UObAVHx4HusnApIJUWrs8hxFAxMCQQC40LA2xUDYvqM9sYx7l98M6K0/LEuRMm8QLt+5lhNCeibh4MZI8kHADsgnqLY7EC4WunAbNFL/AREGMI+WM+lZAkEAwskM9rwSTqpxc2rSAQZ1Myn1mOW9YzfBSw/xgGfhKjbd0BV7yEVTDPbUSCjbk+DYv2G4gz8bty2m5N9YuIUhpQJAcNFDoEuNKEJHV/O4NAIjcLfgef3KK1pEHfbfL2UDYMM8VQpnQERSCrF7UWpVw3w/BjTNFm48c9ns0IB4RlJuEQJBAJ7wpryXOU9wj02vTciXHo955AnrbAVMyu/9flZTVRAZ1XQF5Unt2iSUl0kcwT7njANCX94bZTJilXqJnZK6MS0=</code></pre>\n<p><strong>签名结果示例</strong></p>\n<pre><code>CN0XEbwadVuQWHhTPfvPxCzZkd8VqTHH4TtL4Lx42lcvUxE0w5NfidiAi8q3lnsv83mb/Dc+SAZTmWaMfArgcnmCXKA8ChM1XyPPqNhSJd4RIQ/ZAonax32qJsYl2opC7xlYmo27hNtDzLpQPfux2vvXRHx2lswMLgfL23F1ENo=</code></pre>\n<h3 id=\"46ce3f8577b3c87f60c70ee74e68350e\">验签</h3>\n<p>服务器接收到请求后，用相同的逻辑组装好签名字符串，然后用公钥和接收到的签名验签，UTF-8编码。</p>\n<p><strong>java 验签示例</strong></p>\n<pre><code>    /**\n     * 用公钥和签名字符串对签名进行验证\n     * \n     * @param content \n     * @param sign\n     * @param publicKey\n     * @return\n     */\n    public static boolean rsaCheckContent(String content, String sign, String publicKey) {\n        try {\n            PublicKey pubKey = getPublicKeyFromX509(&quot;RSA&quot;, new ByteArrayInputStream(publicKey.getBytes()));\n            Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;);\n            signature.initVerify(pubKey);\n            signature.update(content.getBytes(StandardCharsets.UTF_8));\n            return signature.verify(Base64.decodeBase64(sign.getBytes()));\n        } catch (Exception var6) {\n            throw new BusinessException(&quot;401001&quot;, var6.getMessage());\n        }\n    }\n    public static PublicKey getPublicKeyFromX509(String algorithm, InputStream ins) throws Exception {\n        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n        byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();\n        encodedKey = Base64.decodeBase64(encodedKey);\n        return keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));\n    }</code></pre>\n<p><strong>签名公钥示例</strong></p>\n<pre><code>MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCWJp6jtuKcpR+g+PiQbM5+dmVfobLFvu+wmqDbJ6zwlLQ/GVwT0OrYjzIZBciTa0jEVLELYTipUg90Pqz6Y7ABgGvuDoRVLPEdqCvb3o90hfu82dOHCiRvny4xsWuEdm5s1W7m2S/gQJPWNqmtSClezTUu409/DurBMxUQYpNcmwIDAQAB</code></pre>\n<p><strong>java 签名验签工具类示例</strong></p>\n<pre><code>\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.text.NumberFormat;\nimport java.util.*;\n\npublic class SignatureUtil {\n\n\n    public static String getSignContent(Map&lt;String, Object&gt; params) {\n        params.remove(&quot;sign&quot;);\n        // 移除数组和集合\n        params.entrySet().removeIf(entry -&gt; entry.getValue().getClass().isArray() || entry.getValue() instanceof Collection&lt;?&gt; || entry.getValue() instanceof Map&lt;?, ?&gt;);\n        StringJoiner stringJoiner = new StringJoiner(&quot;&amp;&quot;);\n        List&lt;String&gt; keys = new ArrayList(params.keySet());\n        Collections.sort(keys);\n        keys.stream().filter(StringUtils::notBlank).forEach(key -&gt; {\n            Object value = params.get(key);\n            if (value instanceof Number) {\n                NumberFormat nf = NumberFormat.getInstance();\n                nf.setGroupingUsed(false);\n                value = nf.format(value);\n            }\n            stringJoiner.add(key + &quot;=&quot; + value.toString());\n        });\n\n        return stringJoiner.toString();\n    }\n\n\n    public static String rsaSign(Map&lt;String, Object&gt; params, String privateKey) throws Exception {\n        String signContent = getSignContent(params);\n        return rsaSign(signContent, privateKey);\n    }\n\n    /**\n     * 用私钥对待签名字符串进行签名\n     *\n     * @param content\n     * @param privateKey\n     * @return\n     */\n    public static String rsaSign(String content, String privateKey) throws Exception {\n        PrivateKey priKey = getPrivateKeyFromPKCS8(&quot;RSA&quot;, new ByteArrayInputStream(privateKey.getBytes()));\n        Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;);\n        signature.initSign(priKey);\n        signature.update(content.getBytes(StandardCharsets.UTF_8));\n\n        byte[] signed = signature.sign();\n        return new String(Base64.encodeBase64(signed));\n    }\n\n    public static PrivateKey getPrivateKeyFromPKCS8(String algorithm, InputStream ins) throws Exception {\n        if (ins != null &amp;&amp; !StringUtils.isBlank(algorithm)) {\n            KeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n            byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();\n            encodedKey = Base64.decodeBase64(encodedKey);\n            return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(encodedKey));\n        } else {\n            return null;\n        }\n    }\n\n\n    public static boolean rsaCheck(Map&lt;String, Object&gt; params, String publicKey) throws Exception {\n        String sign = (String) params.get(&quot;sign&quot;);\n        String content = getSignContent(params);\n        return rsaCheckContent(content, sign, publicKey);\n    }\n\n\n    /**\n     * 用公钥和签名字符串对签名进行验证\n     *\n     * @param content\n     * @param sign\n     * @param publicKey\n     * @return\n     */\n    public static boolean rsaCheckContent(String content, String sign, String publicKey) throws Exception {\n        PublicKey pubKey = getPublicKeyFromX509(&quot;RSA&quot;, new ByteArrayInputStream(publicKey.getBytes()));\n        Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;);\n        signature.initVerify(pubKey);\n        signature.update(content.getBytes(StandardCharsets.UTF_8));\n\n        return signature.verify(Base64.decodeBase64(sign.getBytes()));\n    }\n\n    public static PublicKey getPublicKeyFromX509(String algorithm, InputStream ins) throws Exception {\n        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);\n        byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();\n        encodedKey = Base64.decodeBase64(encodedKey);\n        return keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));\n    }\n\n}</code></pre>\n","key":"609fc86828054c4b31786b98ff68d480","fileName":"__docs_01-网关签名_02-网关签名验签.json","mtimeMs":1634893747000,"birthtimeMs":1634893747000}