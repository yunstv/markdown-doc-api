# 03-回调地址接口实现

### 请求类型

* POST

### 请求参数

`requestBody`

| 参数            | 类型   | 是否必填 | 描述                                                         |
| --------------- | ------ | -------- | ------------------------------------------------------------ |
| sign            | String | 是       | 将request_content、timestamp、nonce按字典排序后RSA签名后的Base64字符串 |
| request_content | String | 是       | 回调接口请求体字符串                                         |
| timestamp       | Long   | 是       | 13位时间戳                                                   |
| nonce           | String | 是       | 6位随机字符                                                  |
| message_type    | String | 是       | 消息类型                                                     |

### 请求样例

```json
{
  "sign":"Ea6kxCUj1y06D8fSqzCPd2NUqQ8ygcwkTDXMYeUY5A6MRdlWWTdz09KnReHMLQGwbSMYMB7UdBjzR43xwoiT+AE9Sh9MCV8c4Z/l9EE5lE8E3ftN9D1D+PybVE6iZ9+jOhaTGpk49MF2ln9Gkfq6qzfCEFrTrR6livScJj+bGz4HpDhENW45XhRaMyuFr7xdrLbE4aTw7VoLiK3xNrIpnd7/SgFgJ8D1hyFyF1l9GfkFUFQAN+O2HZgBUUcCALItsJhgujKtdrrAHDkBPbrliEDncOcnttXYtSan+rt4tmtEL8rG0Ha+N8kR9uvzHAFpdIqsjUqv0SAQAx/Y6q9g8A==",
    "request_content":"{\"field1\":\"业务字段1\",\"field2\":\"业务字段1\"}",
    "timestamp":1620714106666,
    "nonce":"d94f38",
    "message_type":"ecode-ac.reject"
}
```

### 响应成功标志

Http Status Code: 200，响应体中code值为"000":

```json
{
    "code":"000",
    ...
}
```



### 回调验签规则

签名原文获取——将请求体中的timestamp、nonce、request_content字段进行字典排序，参数和值之间用=连接，参数之间用&连接。message_type不参与验签。

**签名原文实例**

```
nonce=d94f38&request_content={\"field1\":\"业务字段1\",\"field2\":\"业务字段1\"}&timestamp=1620714106666
```

### 回调验签样例

```java
public void testCallback(@RequestBody JsonNode request) {
    //将timestamp、nonce、request_content进行字典排序，参数和值之间用=连接，参数之间用&连接。
    final String content = "nonce=" + request.get("nonce").asText() +
                "&request_content=" + request.get("request_content").asText() +
                "&timestamp=" + request.get("timestamp").asText();
    //获取签名信息
    String sign = request.get("sign").asText();
    final boolean verify = rsaCheckContent(content, sign, publicKey);
    log.info("验签结果:{}", verify);
}

/**
 * 用公钥和签名字符串对签名进行验证
 *
 * @param content
 * @param sign
 * @param publicKey
 * @return
 */
public static boolean rsaCheckContent(String content, String sign, String publicKey) {
    try {
        PublicKey pubKey = getPublicKeyFromX509("RSA", new ByteArrayInputStream(publicKey.getBytes()));
        Signature signature = Signature.getInstance("SHA1WithRSA");
        signature.initVerify(pubKey);
        signature.update(content.getBytes(StandardCharsets.UTF_8));
        return signature.verify(Base64.decodeBase64(sign.getBytes()));
    } catch (Exception var6) {
        throw new BusinessException("401001", var6.getMessage());
    }
}
public static PublicKey getPublicKeyFromX509(String algorithm, InputStream ins) throws Exception {
    KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
    byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();
    encodedKey = Base64.decodeBase64(encodedKey);
    return keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));
}
```

