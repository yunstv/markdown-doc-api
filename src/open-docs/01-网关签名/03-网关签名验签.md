## 网关签名验签

### 1. 接入网关签名

 对于接入开放平台网关，需要自行实现签名过程，以下为签名介绍。

#### 排序与拼接

 对请求参数`app_id`、`nonce`、`timestamp`、`api_code`、`request_content`按照第一个字符的键值 ASCII 码递增排序（字母升序排序），参数和参数值之间用`=`连接，参数之间用`&`连接。 

 用`私钥（ETC平台获取）`对UTF-8编码的签名字符串进行RSA签名,签名算法为`SHA1WithRSA`。
 
#### 签名示例

**签名字符串示例**

```
api_code=test.add&app_id=OIG0AF4DMOK2VC2N&nonce=123AO9&request_content={"name":"测试"}&timestamp=1604990109987
```

**java 签名示例**

```
	/**
     * 用私钥对待签名字符串进行签名
     * 
     * @param content 
     * @param privateKey
     * @return
     */
    public static String rsaSign(String content, String privateKey) {
        try {
            PrivateKey priKey = getPrivateKeyFromPKCS8("RSA", new ByteArrayInputStream(privateKey.getBytes()));
            Signature signature = Signature.getInstance("SHA1WithRSA");
            signature.initSign(priKey);
            signature.update(content.getBytes(StandardCharsets.UTF_8));
            byte[] signed = signature.sign();
            return new String(Base64.encodeBase64(signed));
        } catch (Exception var7) {
            throw new BusinessException("401001", var7.getMessage());
        }
    }
    public static PrivateKey getPrivateKeyFromPKCS8(String algorithm, InputStream ins) throws Exception {
        if (ins != null && !StringUtils.isBlank(algorithm)) {
            KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
            byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();
            encodedKey = Base64.decodeBase64(encodedKey);
            return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(encodedKey));
        } else {
            return null;
        }
    }
```

### 2. 网关对内转发签名与验签

#### 2.1 网关签名

 对`requestHeaders`中的`app-id`、`biz-user-id`、`timestamp`、`request-id`按照第一个字符的键值 ASCII 码递增排序（字母升序排序），参数和参数值之间用`=`连接，参数之间用`&`连接。

**待签名字符串示例**

```
app-id=OIG0AF4DMOK2VC2N&request-id=EHfbfL2UDYMM8VQpnQER&timestamp=1604990109987&biz-user-id=E0019182
```

#### 2.2 内部服务验签

 对`requestHeaders`中的`app-id`、`biz-user-id`、`timestamp`、`request-id`按照第一个字符的键值 ASCII 码递增排序（字母升序排序），参数和参数值之间用`=`连接，参数之间用`&`连接。
 
 内部服务接收到请求后，用相同的逻辑组装好签名字符串，然后用公钥和接收到的签名验签，UTF-8编码。

**待验签名字符串示例**

```
app-id=OIG0AF4DMOK2VC2N&request-id=EHfbfL2UDYMM8VQpnQER&timestamp=1604990109987&biz-user-id=E0019182
```

**java 验签示例**

```
    /**
     * 用公钥和签名字符串对签名进行验证
     * 
     * @param content 
     *@param sign
     * @param publicKey
     * @return
     */
    public static boolean rsaCheckContent(String content, String sign, String publicKey) {
        try {
            PublicKey pubKey = getPublicKeyFromX509("RSA", new ByteArrayInputStream(publicKey.getBytes()));
            Signature signature = Signature.getInstance("SHA1WithRSA");
            signature.initVerify(pubKey);
            signature.update(content.getBytes(StandardCharsets.UTF_8));
            return signature.verify(Base64.decodeBase64(sign.getBytes()));
        } catch (Exception var6) {
            throw new BusinessException("401001", var6.getMessage());
        }
    }
    public static PublicKey getPublicKeyFromX509(String algorithm, InputStream ins) throws Exception {
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();
        encodedKey = Base64.decodeBase64(encodedKey);
        return keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));
    }
```

**java 签名验签工具类示例**

```
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.io.IOUtils;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.text.NumberFormat;
import java.util.*;

public class SignatureUtil {


    public static String getSignContent(Map<String, Object> params) {
        params.remove("sign");
        StringJoiner stringJoiner = new StringJoiner("&");
        List<String> keys = new ArrayList(params.keySet());
        Collections.sort(keys);
        keys.stream().filter(StringUtils::notBlank).forEach(key -> {
            Object value = params.get(key);
            stringJoiner.add(key + "=" + value.toString());
        });

        return stringJoiner.toString();
    }


    public static String rsaSign(Map<String, Object> params, String privateKey) throws Exception {
        String signContent = getSignContent(params);
        return rsaSign(signContent, privateKey);
    }

    /**
     * 用私钥对待签名字符串进行签名
     *
     * @param content
     * @param privateKey
     * @return
     */
    public static String rsaSign(String content, String privateKey) throws Exception {
        PrivateKey priKey = getPrivateKeyFromPKCS8("RSA", new ByteArrayInputStream(privateKey.getBytes()));
        Signature signature = Signature.getInstance("SHA1WithRSA");
        signature.initSign(priKey);
        signature.update(content.getBytes(StandardCharsets.UTF_8));

        byte[] signed = signature.sign();
        return new String(Base64.encodeBase64(signed));
    }

    public static PrivateKey getPrivateKeyFromPKCS8(String algorithm, InputStream ins) throws Exception {
        if (ins != null && !StringUtils.isBlank(algorithm)) {
            KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
            byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();
            encodedKey = Base64.decodeBase64(encodedKey);
            return keyFactory.generatePrivate(new PKCS8EncodedKeySpec(encodedKey));
        } else {
            return null;
        }
    }


    public static boolean rsaCheck(Map<String, Object> params, String publicKey) throws Exception {
        String sign = (String) params.get("sign");
        String content = getSignContent(params);
        return rsaCheckContent(content, sign, publicKey);
    }


    /**
     * 用公钥和签名字符串对签名进行验证
     *
     * @param content
     * @param sign
     * @param publicKey
     * @return
     */
    public static boolean rsaCheckContent(String content, String sign, String publicKey) throws Exception {
        PublicKey pubKey = getPublicKeyFromX509("RSA", new ByteArrayInputStream(publicKey.getBytes()));
        Signature signature = Signature.getInstance("SHA1WithRSA");
        signature.initVerify(pubKey);
        signature.update(content.getBytes(StandardCharsets.UTF_8));

        return signature.verify(Base64.decodeBase64(sign.getBytes()));
    }

    public static PublicKey getPublicKeyFromX509(String algorithm, InputStream ins) throws Exception {
        KeyFactory keyFactory = KeyFactory.getInstance(algorithm);
        byte[] encodedKey = IOUtils.toString(ins, StandardCharsets.UTF_8).getBytes();
        encodedKey = Base64.decodeBase64(encodedKey);
        return keyFactory.generatePublic(new X509EncodedKeySpec(encodedKey));
    }

}
```
